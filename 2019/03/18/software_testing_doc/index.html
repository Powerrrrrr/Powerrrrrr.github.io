<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="English">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="软件测试： 使用人工或者自动手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果直接的差别。  软件质量 能满足给定需求的特性  软件需求是满足软件质量的基础，不符合需求的软件就不具备好的质量，设计的软件应在功能，性能等方面都符合要求，并可靠地运行   具有所期望的各种属性的组合的程度  即软件结构良好，合理地利用系统资源，易读，易于理解并易于修改，方便">
<meta property="og:type" content="article">
<meta property="og:title" content="软件测试">
<meta property="og:url" content="http://yoursite.com/2019/03/18/software_testing_doc/index.html">
<meta property="og:site_name" content="Powerrrrrr">
<meta property="og:description" content="软件测试： 使用人工或者自动手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果直接的差别。  软件质量 能满足给定需求的特性  软件需求是满足软件质量的基础，不符合需求的软件就不具备好的质量，设计的软件应在功能，性能等方面都符合要求，并可靠地运行   具有所期望的各种属性的组合的程度  即软件结构良好，合理地利用系统资源，易读，易于理解并易于修改，方便">
<meta property="og:locale" content="English">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/1552648383523.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/F1%20-%20Traditional%20V%20Model.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/timg.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/timg-1552652405003.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/timg-1552652423134.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/1552713247457.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221210001415417.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221210556253202.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221213458284298.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221214109843117.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221214351258993.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221214596567753.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/221216586562242.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/software_testing_doc/772384-20171213175224488-1665785739.jpg">
<meta property="og:updated_time" content="2019-05-13T17:29:39.430Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="软件测试">
<meta name="twitter:description" content="软件测试： 使用人工或者自动手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果直接的差别。  软件质量 能满足给定需求的特性  软件需求是满足软件质量的基础，不符合需求的软件就不具备好的质量，设计的软件应在功能，性能等方面都符合要求，并可靠地运行   具有所期望的各种属性的组合的程度  即软件结构良好，合理地利用系统资源，易读，易于理解并易于修改，方便">
<meta name="twitter:image" content="http://yoursite.com/2019/03/18/software_testing_doc/1552648383523.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/18/software_testing_doc/">





  <title>软件测试 | Powerrrrrr</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Powerrrrrr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/18/software_testing_doc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Runqian Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Powerrrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">软件测试</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-18T18:29:40+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>软件测试：</p>
<p>使用人工或者自动手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果直接的差别。</p>
</blockquote>
<h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><ul>
<li><p>能满足给定需求的特性</p>
<blockquote>
<p>软件需求是满足软件质量的基础，不符合需求的软件就不具备好的质量，设计的软件应在功能，性能等方面都符合要求，并可靠地运行</p>
</blockquote>
</li>
<li><p>具有所期望的各种属性的组合的程度</p>
<blockquote>
<p>即软件结构良好，合理地利用系统资源，易读，易于理解并易于修改，方便软件的维护</p>
</blockquote>
</li>
<li><p>能满足用户综合期望的程度</p>
<blockquote>
<p>软件系统具有友好的用户界面，便于用户使用 </p>
</blockquote>
</li>
<li><p>软件的组合特性</p>
<blockquote>
<p>软件生命周期中各阶段文档齐全，规范，便于配置管理</p>
</blockquote>
</li>
</ul>
<h3 id="软件质量因素"><a href="#软件质量因素" class="headerlink" title="软件质量因素"></a>软件质量因素</h3><p>正确性，可靠性，可使用性，效率，完整性，可维护性，可测试性，灵活性，可以执行，可复用性，互联性等</p>
<h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><p><img src="/2019/03/18/software_testing_doc/1552648383523.png" alt="1552648383523"></p>
<center>McCall 软件质量模型</center>



<h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><ol>
<li>软件未达到规格说明书中规定的功能</li>
<li>软件出现运行错误</li>
<li>软件功能超出产品说明书中指明的范围</li>
<li>软件测试人员认为软件难于理解，不易使用，运行速度慢，或者最终用户认为使用效果不好。</li>
<li>软件没有达到目标</li>
</ol>
<h3 id="缺陷产生原因"><a href="#缺陷产生原因" class="headerlink" title="缺陷产生原因"></a>缺陷产生原因</h3><h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4><p>各种框架模块复杂，软件复杂性高，以及需求变化带来的不确定因素等</p>
<h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><p>开发过程中，开发文档缺失，开发流程不完善，缺乏合理良好的评审机制等</p>
<h4 id="团队工作"><a href="#团队工作" class="headerlink" title="团队工作"></a>团队工作</h4><p>各小组之间的协调不到位，合作不佳等</p>
<h4 id="复审"><a href="#复审" class="headerlink" title="复审"></a>复审</h4><p>没有或过于随意的复审机制</p>
<h3 id="缺陷内容"><a href="#缺陷内容" class="headerlink" title="缺陷内容"></a>缺陷内容</h3><ul>
<li><p>缺陷标识</p>
<blockquote>
<p>标记某个缺陷的唯一表示，可以使用数字符号</p>
</blockquote>
</li>
<li><p>缺陷类型</p>
<blockquote>
<p>根据缺陷的自然属性划分缺陷种类：功能，用户界面，文档，软件包，性能，系统/模块接口</p>
</blockquote>
</li>
<li><p>缺陷严重程度</p>
<blockquote>
<p>因缺陷引起的故障的影响程度：致命，严重，一般，很小</p>
</blockquote>
</li>
<li><p>缺陷产生可能性</p>
<blockquote>
<p>缺陷在产品中发生的可能性：一般用频率表示：总是，通常，有时，很少</p>
</blockquote>
</li>
<li><p>缺陷优先级</p>
<blockquote>
<p>缺陷必须被修复的紧急程度</p>
</blockquote>
</li>
<li><p>缺陷状态</p>
<blockquote>
<p>缺陷通过一个跟踪修复过程的进展情况，也就是在软件生命周期中的状态基本定义。</p>
<ul>
<li>激活或打开</li>
<li>已修正或修复</li>
<li>关闭或非激活</li>
<li>重新打开</li>
<li>推迟</li>
<li>保留</li>
<li>不能重现</li>
</ul>
</blockquote>
</li>
<li><p>缺陷起源</p>
</li>
<li><p>缺陷来源</p>
<blockquote>
<p>缺陷所在的地方：需求说明书/设计文档/系统集成接口/数据流/程序代码</p>
</blockquote>
</li>
<li><p>缺陷原因</p>
</li>
</ul>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><blockquote>
<p>测试只能找出程序中的错误，而不能证明程序无错。</p>
</blockquote>
<p>软件测试与软件质量密切联系在一起，软件测试归根结底是为了保证软件质量。</p>
<p>三条服务于测试目标的规则：</p>
<ol>
<li>测试是一个程序的执行过程，其目的在于发现错误</li>
<li>一个好的测试用例很可能会发现至今未察觉的错误</li>
<li>一个成功的测试是发现至今尚未察觉的错误的测试</li>
</ol>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><blockquote>
<p>几条测试的基本原则</p>
</blockquote>
<ul>
<li><p>尽早测试</p>
<blockquote>
<p>由于软件的复杂性和程序性，错误在软件生命周期各个阶段都会发生，不应该将软件测试仅仅看作是软件开发过程中一个独立阶段的工作，应当贯穿到软件开发的各个阶段中。</p>
<p>尽早测试 并不是盲目测，测试开展的前提是达到必须的测试就绪点。</p>
<p>在需求分析设计阶段就应开始测试工作，编写相应的测试文档，一但代码模块完成就展开单元测试，一旦代码模块集成完毕就展开集成测试……</p>
</blockquote>
</li>
<li><p>全面测试</p>
<blockquote>
<p>软件是程序，数据和文档的集合。</p>
<p>对软件的测试，不仅仅是对程序的测试，还应包括软件的副产品的全面测试。</p>
<p>全面测试包含两层含义：</p>
<ol>
<li>对软件的所有产品进行全面的测试，包括需求、设计文档，代码，用户文档等。</li>
<li>软件开发及测试人员全面参与到测试工作中来，例如对需求的验证和确认活动。</li>
</ol>
</blockquote>
</li>
<li><p>全过程测试</p>
<blockquote>
<ol>
<li>测试人员要充分关注开发过程，对开发过程的各种变化及时做出响应</li>
<li>测试人员要对测试的全过程进行全程的跟踪：建立完善的度量与分析机制，通过对自身过程的度量，及时了解过程信息，调整测试策略。</li>
</ol>
</blockquote>
</li>
<li><p>独立的、迭代的测试</p>
<blockquote>
<ol>
<li>将测试从开发中抽象出来，作为一个独立的过程进行管理。</li>
<li>测试工作应该由独立的专业的软件测试机构来完成。</li>
</ol>
<p>第二点是因为程序设计者对自己的程序印象深刻并总以为是正确的，如果是设计错误或者是编程习惯不良留下的隐患，这种错误程序员本人很难发现。</p>
</blockquote>
</li>
<li><p>Pareto 原则</p>
<blockquote>
<p>80% 错误可能起源于 20% 的模块中。</p>
</blockquote>
</li>
<li><p>对测试出的错误结果一定要有一个确认的过程</p>
<blockquote>
<p>A 查出来的错，要由 B 来确认</p>
</blockquote>
</li>
<li><p>制定严格的测试计划</p>
</li>
<li><p>完全测试是不可能的，测试需要终止</p>
<blockquote>
<p>在有限的时间和资源条件下，想要找出所有的软件缺陷是不可能的。中等规模的程序，其路径组合规模巨大，穷举成本高，况且穷举也不能找出所有隐藏的错误。</p>
<p>因此要根据测试出错误的概率以及软件可靠性要求，确定最佳停止测试时间，而不能无限地测试下去。</p>
</blockquote>
</li>
<li><p>注意回归测试的关联性</p>
<blockquote>
<p>回归测试的关联性一定要引起注意，修改一个错误而引起更多错误出现的现象并不少见。</p>
</blockquote>
</li>
<li><p>妥善保存一切测试过程文档</p>
<blockquote>
<p>测试的重要性往往靠测试文档体现。</p>
</blockquote>
</li>
</ul>
<h3 id="软件测试过程模型"><a href="#软件测试过程模型" class="headerlink" title="软件测试过程模型"></a>软件测试过程模型</h3><h4 id="1-V-模型"><a href="#1-V-模型" class="headerlink" title="1. V 模型"></a>1. V 模型</h4><p><img src="/2019/03/18/software_testing_doc/F1 - Traditional V Model.jpg" alt="Image result for software testing V model"></p>
<p>不足：</p>
<p>仅仅把测试作为编码之后的一个阶段，忽视了测试活动对需求分析、系统设计等活动的验证和确认的功能。</p>
<h4 id="2-W-model"><a href="#2-W-model" class="headerlink" title="2. W model"></a>2. W model</h4><p><img src="/2019/03/18/software_testing_doc/timg.jpg" alt="img"></p>
<p>不足：</p>
<p>W 模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可以正式开始下一个阶段工作。这样就无法支持迭代的开发模型。</p>
<h4 id="3-X-model"><a href="#3-X-model" class="headerlink" title="3.  X model"></a>3.  X model</h4><p><img src="/2019/03/18/software_testing_doc/timg-1552652405003.jpg" alt="img"></p>
<h4 id="4-H-Model"><a href="#4-H-Model" class="headerlink" title="4. H Model"></a>4. H Model</h4><p><img src="/2019/03/18/software_testing_doc/timg-1552652423134.jpg" alt="img"></p>
<p>H 模型中，软件测试是一个独立的流程，贯穿产品整个周期，与其他流程并发进行。</p>
<p>H 模型提出软件测试要尽早准备，尽早执行，不同的测试活动可以是按照某个次序先后进行发生的，也可能是反复的，只要某个测试达到了就绪点，就能开始测试执行活动。</p>
<h3 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h3><h4 id="1-按测试方式分类"><a href="#1-按测试方式分类" class="headerlink" title="1. 按测试方式分类"></a>1. 按测试方式分类</h4><ul>
<li><p>静态测试</p>
<blockquote>
<p>不执行程序，查代码。</p>
<p>对程序的数据路和控制流进行分析。</p>
</blockquote>
</li>
<li><p>动态测试</p>
<blockquote>
<p>选择实际测试用例运行程序，模拟用户输入。</p>
</blockquote>
</li>
</ul>
<h4 id="2-按测试方法分类"><a href="#2-按测试方法分类" class="headerlink" title="2. 按测试方法分类"></a>2. 按测试方法分类</h4><ul>
<li><p>白盒测试</p>
<blockquote>
<p>已知软件的实现流程，按照流程测试，测试代码，测试设计等</p>
</blockquote>
</li>
<li><p>黑盒测试</p>
<blockquote>
<p>基于系统应该完成的功能进行测试，功能测试、行为测试、基于需求的测试</p>
</blockquote>
</li>
<li><p>灰盒测试</p>
<blockquote>
<p>灰盒是一种程序或系统上的工作过程被局部认知的装置。</p>
<p>介于白盒测试和黑盒测试之间的一种测试方法，或者说是两者结合，基于对程序内部细节有限认知上的软件调试方法。</p>
</blockquote>
</li>
</ul>
<h4 id="3-按测试过程分类"><a href="#3-按测试过程分类" class="headerlink" title="3. 按测试过程分类"></a>3. 按测试过程分类</h4><ul>
<li><p>单元测试</p>
<blockquote>
<p>通常应用于实施模型中的构件，核实是否已经覆盖控制流和数据流，以及构件是否可以按照预期工作。</p>
<p>包含 界面测试、局部数据结构测试、边界条件测试、覆盖条件测试、出错处理</p>
</blockquote>
</li>
<li><p>集成测试</p>
<blockquote>
<p>主要目标是发现与结构有关的问题：主要测试模块之间数据传输是否正确、模块集成后的功能是否实现、模块接口功能与设计需求是否一致。</p>
<p>单元测试通过后，便可以开始配置集成测试环境。</p>
</blockquote>
</li>
<li><p>系统测试</p>
<blockquote>
<p>将被测试的软件，作为整个基于计算机系统的一项元素，与计算机硬件、外部系统等其他系统元素结合在一起，在实际运作环境下，对计算机系统进行一系列的测试，全面查找被测试系统的错误。</p>
</blockquote>
</li>
<li><p>验收测试</p>
<blockquote>
<p>为了检验接受测试的系统是否满足需求，测试的重点是测试产品在常规条件下的使用情况，主要由市场、销售、技术支持人员和最终用户一起按规定的需求，逐项进行有效性测试，检验软件的功能和性能以及其他特性是否与用户的要求相一致。</p>
<p>一般是黑盒测试。</p>
</blockquote>
</li>
</ul>
<h4 id="4-按测试目的分类"><a href="#4-按测试目的分类" class="headerlink" title="4. 按测试目的分类"></a>4. 按测试目的分类</h4><blockquote>
<p>这里奇奇怪怪，压力测试和负载测试以及强度测试感觉很乱，和网上说的也不大一致。</p>
</blockquote>
<ul>
<li><p>功能测试</p>
</li>
<li><p>健壮性测试</p>
</li>
<li><p>接口测试</p>
</li>
<li><p>性能测试</p>
</li>
<li><p>强度测试</p>
<blockquote>
<p>迫使系统在异常的资源配置下运行。</p>
<p>目的是为了找出因资源不足或资源争用而导致的错误</p>
</blockquote>
</li>
<li><p>压力测试</p>
<blockquote>
<p>在超负荷环境中，检验程序是否能够正常运行。</p>
</blockquote>
</li>
<li><p>用户界面测试</p>
<blockquote>
<p>测试用户界面是否友好、软件是否方便易用、系统设计是否合理、界面位置是否正确</p>
</blockquote>
</li>
<li><p>安全测试</p>
</li>
<li><p>可靠性测试</p>
</li>
<li><p>安装/反安装测试</p>
<blockquote>
<p>即安装及删除测试</p>
</blockquote>
</li>
<li><p>文档测试</p>
</li>
<li><p>恢复测试</p>
<blockquote>
<p>主要测试当出现系统崩溃、硬件错误或者其他灾难性问题时系统的表现情况，以及系统从故障中恢复的能力。</p>
</blockquote>
</li>
<li><p>兼容性测试</p>
</li>
<li><p>负载测试</p>
<blockquote>
<p>通过测试系统在资源超负荷情况下的表现，已发现设计上的错误或验证系统的负载能力。</p>
</blockquote>
</li>
</ul>
<h3 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h3><blockquote>
<p>从软件测试开始到软件测试结束为止所经过的一系列准备、执行、分析的过程。、</p>
<p>一般要通过 制定测试计划、设计测试、测试准备、测试环境的建立、执行测试、评估测试和总结测试等几个阶段来完成。</p>
</blockquote>
<h4 id="1-制定测试计划"><a href="#1-制定测试计划" class="headerlink" title="1. 制定测试计划"></a>1. 制定测试计划</h4><blockquote>
<p>重点在于对整个项目的测试工作进行计划，测试计划并不是一张时间进度表，而是一个动态的过程，最终以系列文档的形式确定下来。</p>
<p>目的是 识别任务、分析风险、规划资源和确定进度。</p>
</blockquote>
<p>测试计划包括以下几个方面：</p>
<ul>
<li><p>软件测试背景</p>
<blockquote>
<p>项目介绍，人员介绍等</p>
</blockquote>
</li>
<li><p>软件测试依据</p>
<blockquote>
<p>软件需求文档，规格书，软件设计文档等</p>
</blockquote>
</li>
<li><p>测试范围的界定</p>
<blockquote>
<p>确定测试工作需要覆盖的范围。</p>
<p>实际工作中，人们总是不自觉调整软件测试的范围。比如在时间紧张的情况下，通常优先完成重要功能的测试。</p>
</blockquote>
</li>
<li><p>风险的确定</p>
<blockquote>
<p>项目开发中，首先需要识别出存在的风险，识别出风险之后，需要对照这些风险制定出规避风险的办法。</p>
</blockquote>
</li>
<li><p>测试资源</p>
<blockquote>
<p>确定完成任务需要消耗的人力资源、物资资源，包括测试设备需求、人员需求、测试环境需求以及其他资源需求。</p>
</blockquote>
</li>
<li><p>测试策略</p>
<blockquote>
<p>测试策略主要包括采取测试的方法、搭建的环境、采用哪些测试工具和测试管理工具、对测试人员进行培训等</p>
</blockquote>
</li>
<li><p>时间表的制定</p>
</li>
<li><p>其他</p>
<blockquote>
<p>测试计划还包括测试计划编写的日期、作者等信息</p>
</blockquote>
</li>
</ul>
<h4 id="2-设计测试方案"><a href="#2-设计测试方案" class="headerlink" title="2. 设计测试方案"></a>2. 设计测试方案</h4><blockquote>
<p>设计测试用例和测试过程，要保证测试用例完全符合测试需求。</p>
</blockquote>
<p>测试用例的完成并不是一劳永逸的，因为测试用例是来源于测试需求的。</p>
<p>一般来说，测试人员可以根据不同阶段已经确定下来的测试需求来进行测试用例的设计，然后随着开发过程的继续，在测试需求增补或修改后不断地调整测试用例。</p>
<h4 id="3-测试准备和测试环境的建立"><a href="#3-测试准备和测试环境的建立" class="headerlink" title="3. 测试准备和测试环境的建立"></a>3. 测试准备和测试环境的建立</h4><blockquote>
<p>准备阶段需要完成测试前的各项准备工作：</p>
<p>全面准确掌握各种测试资料，进一步了解、熟悉测试软件，配置测试的软件硬件环境，搭建测试平台，充分熟悉和掌握测试工具等工作。</p>
</blockquote>
<h4 id="4-执行测试"><a href="#4-执行测试" class="headerlink" title="4. 执行测试"></a>4. 执行测试</h4><blockquote>
<p>分成：</p>
<p>单元测试 → 集成测试 → 系统测试 → 验收测试</p>
<p>其中每个阶段都包含 <strong>回收测试</strong></p>
</blockquote>
<h4 id="5-测试评估"><a href="#5-测试评估" class="headerlink" title="5. 测试评估"></a>5. 测试评估</h4><p>主要方法：</p>
<ul>
<li><p>缺陷评估</p>
<blockquote>
<p>评估当前软件的可靠性</p>
</blockquote>
</li>
<li><p>覆盖评估</p>
<blockquote>
<p>对测试完成度的评测</p>
</blockquote>
</li>
<li><p>质量评测</p>
<blockquote>
<p>对测试软件的可靠性、稳定性以及性能的评测，它建立在对测试结果的评估和对测试过程中确定的缺陷分析的基础上。</p>
</blockquote>
</li>
</ul>
<h4 id="6-测试总结"><a href="#6-测试总结" class="headerlink" title="6. 测试总结"></a>6. 测试总结</h4><blockquote>
<p>测试的每个阶段都有相应的总结，测试软件的每个版本也应有相应的测试总结。</p>
</blockquote>
<h2 id="软件测试计划制定"><a href="#软件测试计划制定" class="headerlink" title="软件测试计划制定"></a>软件测试计划制定</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>制定计划应尽早开始</li>
<li>保持测试计划的灵活性</li>
<li>保持测试计划简单易读</li>
<li>尽量争取多方面来评审测试计划</li>
<li>计算测试计划的投入</li>
</ol>
<h3 id="如何制定测试计划"><a href="#如何制定测试计划" class="headerlink" title="如何制定测试计划"></a>如何制定测试计划</h3><ol>
<li><p>认真做好测试资料的收集整理工作</p>
<blockquote>
<p>软件的类别及其构成，软件的用户界面，在所测试的软件涉及第三方软件的情况下，必须对第三方软件的功能及它与所要测试的软件之间的联系有着一定的了解</p>
</blockquote>
</li>
<li><p>明确测试的目标，增强计划的实用性</p>
<blockquote>
<p>测试目标必须是明确的，可以度量的，而不是摸棱两可的宏观描述。</p>
</blockquote>
</li>
<li><p>坚持 “5W” 规则，明确内容与过程</p>
<blockquote>
<p>What，Why，When，Where，How</p>
</blockquote>
</li>
<li><p>采用评审和更新机制，保证测试计划满足实际需求</p>
<blockquote>
<p>测试计划包含多方面的内容，由于编写人员可能受自身测试经验核对软件需求的理解所限，而且软件开发是一个渐进的过程，所以最初创建的测试计划可能是不完善的。</p>
</blockquote>
</li>
</ol>
<h3 id="衡量测试计划的标准"><a href="#衡量测试计划的标准" class="headerlink" title="衡量测试计划的标准"></a>衡量测试计划的标准</h3><ol>
<li>测试计划应能有效地引导整个软件测试工作正常运行，并能使测试部门配合编程部门，保证软件质量，按时将产品推出。</li>
<li>测试计划所提供的方法应能使测试高效地进行，即能在较短的时间内找出尽可能多的软件缺陷。</li>
<li>测试计划应该能够提供明确的测试目标、测试策略、具体步骤以及测试标准。</li>
<li>既要强调测试重点，也要重视测试基本覆盖率。</li>
<li>测试方案应尽可能充分利用公司所能提供给测试部门的人力物力。</li>
<li>测试计划所类举的所有数据都必须准确。</li>
<li>测试计划对测试工作的安排应有一定的灵活性。</li>
</ol>
<h3 id="制定测试计划"><a href="#制定测试计划" class="headerlink" title="制定测试计划"></a>制定测试计划</h3><ol>
<li><p>测试计划标识符</p>
<blockquote>
<p>唯一值，标识测试计划的版本，等级以及测试计划相关的软件版本</p>
</blockquote>
</li>
<li><p>简要介绍</p>
<blockquote>
<p>对测试软件的基本情况介绍和对测试范围的概括性描述等</p>
</blockquote>
</li>
<li><p>测试项目</p>
<blockquote>
<p>包括所测试的软件的名称及版本，列出所有测试单项、外部条件对测试特性的影响和软件缺陷报告的机制等</p>
</blockquote>
</li>
<li><p>测试对象</p>
</li>
<li><p>不需要测试的对象</p>
</li>
<li><p>测试方法(策略)</p>
<blockquote>
<p>描述如何进行测试，并解释对测试成功与否起决定作用的所有相关问题。</p>
</blockquote>
</li>
<li><p>项目通过/失败的标准</p>
<blockquote>
<p>一些常用指标：</p>
<ul>
<li>通过的测试用例占所有的测试用例的情况</li>
<li>缺陷的数量、严重程度和分布情况</li>
<li>测试用例覆盖情况</li>
<li>用户对测试的成功结论</li>
<li>文档的完整性</li>
<li>是否达到性能标准</li>
</ul>
</blockquote>
</li>
<li><p>中断测试和恢复测试的判断准则</p>
</li>
<li><p>测试完成所提交的材料</p>
<blockquote>
<p>测试完成所提交的材料包括测试工作中所有的文档、工具等</p>
</blockquote>
</li>
<li><p>测试任务</p>
</li>
<li><p>测试所需的资源</p>
<blockquote>
<p>资源是实现测试策略所必需的</p>
</blockquote>
</li>
<li><p>测试人员的工作职责</p>
</li>
<li><p>人员安排和培训需求</p>
</li>
<li><p>测试进度表</p>
</li>
<li><p>风险及应对措施</p>
</li>
<li><p>审批</p>
</li>
</ol>
<h2 id="软件测试基本技术"><a href="#软件测试基本技术" class="headerlink" title="软件测试基本技术"></a>软件测试基本技术</h2><p><img src="/2019/03/18/software_testing_doc/1552713247457.png" alt="1552713247457"></p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><blockquote>
<p>对软件的过程性细节做细致的检查，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同的点检查程序状态，确定实际状态是否与预期的状态一致。</p>
<p>因此白盒测试又称为结构测试或逻辑驱动测试。</p>
</blockquote>
<h4 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h4><h5 id="1-代码检查法"><a href="#1-代码检查法" class="headerlink" title="1. 代码检查法"></a>1. 代码检查法</h5><blockquote>
<p>对以下内容进行检查：</p>
<ul>
<li>检查代码和设计的一致性</li>
<li>代码的可读性以及对软件设计标准的遵循情况</li>
<li>代码逻辑表达的正确性</li>
<li>代码结构的合理性</li>
<li>程序中不安全、不明确和模糊的部分</li>
<li>编程风格方面的问题</li>
</ul>
</blockquote>
<p>代码检查项目：</p>
<ul>
<li><p>检查变量的交叉引用表</p>
<blockquote>
<p>检查未说明的变量、违反了类型规定的变量以及变量的引用和使用情况</p>
</blockquote>
</li>
<li><p>检查标号的交叉引用表</p>
<blockquote>
<p>验证所有标号的正确性以及转向指定位置的标号是否正确</p>
</blockquote>
</li>
<li><p>检查子程序、宏、函数</p>
<blockquote>
<p>验证每次调用与所调用位置是否正确，调用的子程序、宏、函数是否存在，参数是否一致，调用序列中调用方式与参数个数、类型等的一致性</p>
</blockquote>
</li>
<li><p>等价性检查</p>
<blockquote>
<p>检查全部等价变量的类型的一致性</p>
</blockquote>
</li>
<li><p>常量检查</p>
<blockquote>
<p>确认常量的取值和数制、数据类型，检查常量每次引用同它的取值、数制和类型的一致性</p>
</blockquote>
</li>
<li><p>设计标准检查</p>
<blockquote>
<p>检查程序是否违反设计标准</p>
</blockquote>
</li>
<li><p>风格检查</p>
<blockquote>
<p>检查程序的设计风格方面的问题</p>
</blockquote>
</li>
<li><p>比较控制流</p>
<blockquote>
<p>比较设计控制流图和实际程序生成的控制流图的差异</p>
</blockquote>
</li>
<li><p>选择、激活路径</p>
<blockquote>
<p>在设计控制流图中选择某条路径，到实际的程序中激活这条路径，如果不能激活，则程序可能有错误。</p>
</blockquote>
</li>
<li><p>对照程序的规格说明，详细阅读源代码</p>
<blockquote>
<p>逐字逐句进行分析和思考，将实际的代码和期望的代码进行比较，发现程序的问题和错误。</p>
</blockquote>
</li>
</ul>
<p>代码检查的方式：</p>
<ul>
<li><p>桌面检查</p>
<blockquote>
<p>程序设计人员对源程序代码进行分析、检验，并补充相关的文档，发现程序中的错误</p>
</blockquote>
</li>
<li><p>代码审查</p>
<blockquote>
<p>代码审查一般由程序设计人员和测试人员组成审查小组，通过阅读、讨论，对程序进行静态分析</p>
</blockquote>
</li>
<li><p>走查</p>
<blockquote>
<p>走查一般由程序设计人员和测试人员组成审查小组通过的逻辑运行程序，发现问题。</p>
</blockquote>
</li>
</ul>
<h5 id="2-静态结构分析法"><a href="#2-静态结构分析法" class="headerlink" title="2. 静态结构分析法"></a>2. 静态结构分析法</h5><blockquote>
<p>测试人员通常使用测试工具分析程序源代码的系统结构、数据结构、数据接口、内部控制逻辑等内部结构，生成函数调用关系图、模块控制流图、内部文件调用关系图等各种图形图表，清晰地标识整个软件的组成结构。</p>
</blockquote>
<p>方法：</p>
<ul>
<li><p>生成各种图表，来帮助对源程序的分析</p>
<blockquote>
<p>常用的引用表：</p>
<ul>
<li>标号交叉引用表</li>
<li>变量交叉引用表</li>
<li>子程序引用表</li>
<li>等价表</li>
<li>常数表</li>
</ul>
<p>图：</p>
<p>函数关系调用图、模块控制流图</p>
</blockquote>
</li>
<li><p>静态错误分析</p>
<blockquote>
<p>主要用于确定在源程序中是否有某类错误或“危险”结构</p>
</blockquote>
<ul>
<li><p>类型和单位分析</p>
<blockquote>
<p>强化对源程序中数据类型的检查</p>
</blockquote>
</li>
<li><p>引用分析</p>
<blockquote>
<p>最广泛使用的静态错误分析方法就是 发现引用异常。</p>
<p>检测引用异常需要检查通过程序的每一条路径，通常采用类似深度优先的方法遍历程序流程图的每一条路径，也可建立引用引出探测工具，这种工具包含两个表：定义表和未引用表。</p>
</blockquote>
</li>
<li><p>表达式分析</p>
<blockquote>
<p>错误：</p>
<ol>
<li>在表达式中不正确地使用括号</li>
<li>数组下标越界</li>
<li>除数为零</li>
<li>复数开平方</li>
<li>对 $\pi$ 求正切值</li>
<li>…</li>
</ol>
</blockquote>
</li>
<li><p>接口分析</p>
<blockquote>
<p>检查模块之间接口的一致性和模块与外部数据库之间接口的一致性</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><h5 id="1-程序插桩"><a href="#1-程序插桩" class="headerlink" title="1. 程序插桩"></a>1. 程序插桩</h5><blockquote>
<p>借助向被测程序插入操作，来实现测试目的的方法</p>
</blockquote>
<p>设计插桩程序需要考虑的问题：</p>
<ul>
<li><p>探测哪些信息？</p>
</li>
<li><p>在程序的什么部位设置探测点？</p>
<blockquote>
<p>一些常见的位置：程序块第一个可执行语句之前、return 语句之后、goto 语句之后…</p>
</blockquote>
</li>
<li><p>需要设置多少个探测点？</p>
<blockquote>
<p>考虑设置最少探测点的方案</p>
</blockquote>
</li>
<li><p>如何在程序中特定部位插入某些用以判断变量特性的语句</p>
<blockquote>
<p>断言</p>
</blockquote>
</li>
</ul>
<h5 id="2-逻辑覆盖"><a href="#2-逻辑覆盖" class="headerlink" title="2. 逻辑覆盖"></a>2. 逻辑覆盖</h5><blockquote>
<p>以程序内部的逻辑结构为基础的测试技术，是通过对程序逻辑结构的便利实现程序测试的覆盖，这种方法要求测试人员对程序的逻辑结构有清楚的了解。</p>
</blockquote>
<p><strong>逻辑覆盖类型</strong>：</p>
<ul>
<li><p>语句覆盖</p>
<blockquote>
<p>设计若干个测试用例，运行被测试程序，使得每一条可执行语句至少执行一次。</p>
</blockquote>
</li>
<li><p>判定覆盖(分支覆盖)</p>
<blockquote>
<p>设计若干个测试用例，运行被测试程序，使每个判断的真假分支至少执行一次</p>
</blockquote>
</li>
<li><p>条件覆盖</p>
<blockquote>
<p>设计足够多测试用例，运行被测试程序，使每个判断的每个条件的每个可能取值至少执行一次</p>
</blockquote>
</li>
<li><p>判定/条件组合覆盖：</p>
<blockquote>
<p>设计足够多测试用例，运行被测试程序，使每个判断的每个条件的所有可能取值至少执行一次，并且每个可能的结果也至少执行一次</p>
<p>即要求各个判断的所有可能的条件取值组合至少执行一次</p>
</blockquote>
</li>
<li><p>条件组合覆盖</p>
<blockquote>
<p>设计足够多的测试用例，运行被测程序，是程序中每个判断的所有可能的条件取值组合至少执行一次</p>
</blockquote>
</li>
</ul>
<p><strong>测试覆盖准则</strong>：</p>
<ul>
<li><p>错误敏感测试用例分析规则 (Error Sensitive Test Cases Analysis) — ESTCA</p>
<blockquote>
<ol>
<li><p>对于 A rel B 型的分支谓词，应适当选择 A B 的值，使 A &gt; B, A&lt; B, A = B 都出现一次</p>
</li>
<li><p>对于 A rel c 型 (c 是常量) 的分支谓词，适当选择 A 的值：</p>
<ul>
<li><p>当 rel 为 &lt; 时，使 A = c - M </p>
<blockquote>
<p>M 是距 c 最小的机器容许的证书，若 A 和 c 均为整型时，M = 1</p>
</blockquote>
</li>
<li><p>同样的当 rel 为 &gt; 时，A = c + M</p>
</li>
</ul>
</li>
<li><p>对外部输入变量赋值，使其在每一测试用例中具有不同的值和符号，并与同一组测试用例中其他变量的值和符号不一样。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>线性代码序列与跳转覆盖规则 (Linear Code Sequence And Jump) — LCSAJ</p>
<blockquote>
<p>分层的覆盖法则</p>
<p>第一层：语句覆盖</p>
<p>第二层：分支覆盖</p>
<p>第三层：LCSAJ 覆盖</p>
<p>第四层：两两 LCSAJ 覆盖</p>
<p>…</p>
<p>第 n+2 层：每 n 个首尾相连的 LCSAJ 组合在测试中都要经历一次</p>
</blockquote>
</li>
</ul>
<h5 id="3-基本路径测试"><a href="#3-基本路径测试" class="headerlink" title="3. 基本路径测试"></a>3. 基本路径测试</h5><blockquote>
<p>在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。</p>
<p>基本路径测试中，设计出的测试用例要保证在被测程序的每一条可执行语句至少执行一次。</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>画出程序控制流程图</p>
</li>
<li><p>计算程序环路复杂性</p>
<blockquote>
<p>程序的环路复杂性给出了程序基本路径集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</p>
<p>三种方法：</p>
<ul>
<li>将环路复杂性定义为程序控制流图中的区域数</li>
<li>设 E 为程序控制流图的边数，N 为图的节点数，则定义环路的复杂性为 V(G) = E - N + 2</li>
<li>设 P 为程序控制流图中的判定节点数，则有 V(G) = P + 1</li>
</ul>
</blockquote>
</li>
<li><p>确定独立路径集合</p>
<blockquote>
<p>V(G) 值等于独立路径条数</p>
</blockquote>
</li>
<li><p>准备测试用例</p>
<blockquote>
<p>选择适当数据，确保基本路径集中每一条路径的执行</p>
</blockquote>
</li>
</ol>
<p>工具：</p>
<p>图形矩阵(邻接矩阵)</p>
<p>邻接矩阵中，某行有 2 个或更多的 ‘1’，则这行所代表的节点一定是一个判定节点。</p>
<h4 id="其他白盒测试方法"><a href="#其他白盒测试方法" class="headerlink" title="其他白盒测试方法"></a>其他白盒测试方法</h4><h5 id="1-域测试"><a href="#1-域测试" class="headerlink" title="1. 域测试"></a>1. 域测试</h5><blockquote>
<p>一种基于程序结构的测试方法</p>
</blockquote>
<p>程序错误分成三类：</p>
<ul>
<li><p>域错误</p>
<blockquote>
<p>如果程序的控制流有错误，对应某一特定输入可能执行的是一条错误路径，这种错误即路径错误，也称为域错误</p>
</blockquote>
</li>
<li><p>计算型错误</p>
<blockquote>
<p>对于某输入，执行的是正确路径，但是由于赋值等语句致使错误，为计算型错误</p>
</blockquote>
</li>
<li><p>丢失路径错误</p>
<blockquote>
<p>程序中某处缺少一个判定谓词引起的错误</p>
</blockquote>
</li>
</ul>
<p>“域”指的是 程序的输入空间，测试方法是基于对输入空间的分析。</p>
<p>基本路径测试法是在分析输入与的基础上，选择适当的测试点以后进行的测试。</p>
<p>域测试缺点：</p>
<ol>
<li>为进行域测试而对程序提出的限制过多</li>
<li>当程序存在很多路径时，需要的测试也就越多</li>
</ol>
<h5 id="2-符号测试"><a href="#2-符号测试" class="headerlink" title="2. 符号测试"></a>2. 符号测试</h5><blockquote>
<p>基本思想：允许程序不仅仅输入具体的数值数据，也可以输入符号值。</p>
</blockquote>
<h5 id="3-Z-路径覆盖"><a href="#3-Z-路径覆盖" class="headerlink" title="3. Z 路径覆盖"></a>3. Z 路径覆盖</h5><blockquote>
<p>一般称简化循环意义下的路径覆盖为 Z 路径覆盖</p>
</blockquote>
<p>无论循环的形式和实际执行循环体的次数，只考虑循环一次和零次两种情况，即只考虑执行时进入循环体一次和跳过循环体这两种情况。</p>
<h5 id="4-程序变异"><a href="#4-程序变异" class="headerlink" title="4. 程序变异"></a>4. 程序变异</h5><blockquote>
<p>一种错误驱动测试，错误驱动方法是针对某类特定程序错误的。</p>
</blockquote>
<h4 id="白盒测试应用策略"><a href="#白盒测试应用策略" class="headerlink" title="白盒测试应用策略"></a>白盒测试应用策略</h4><ul>
<li><p>测试中，应尽量先使用工具进行静态结构分析</p>
</li>
<li><p>测试中可采取先静态后动态的组合方式</p>
<blockquote>
<p>先进行静态结构分析、代码检查，在进行覆盖测试</p>
</blockquote>
</li>
<li><p>利用静态分析的结果作为引导，通过代码检查和动态测试的方式对静态分析结果进一步确认</p>
</li>
<li><p>覆盖测试是白盒测试的重点，一般可使用基本路径测试法达到语句覆盖标准</p>
</li>
<li><p>不同的测试节点，测试的侧重点不同</p>
<ul>
<li>单元测试阶段以代码价差、逻辑覆盖为主</li>
<li>集成测试阶段需要加入静态结构分析</li>
<li>系统测试阶段，应根据黑盒测试的结果，采取相应的白盒测试</li>
</ul>
</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><blockquote>
<p>测试实在软件的接口处进行，测试人员完全不需考虑程序的逻辑结构和内部特性，只依据程序的需求规格说明书和用户手册，来检查程序的功能。</p>
<p>因此黑盒测试又叫数据驱动测试。</p>
</blockquote>
<p>主要依据：规格说明书和用户手册</p>
<p>主要是为了发现：</p>
<ul>
<li>是否有不正确或遗漏的功能</li>
<li>接口上，输入是否能正确地接受、结果是否正确</li>
<li>是否有数据结构错误或外部信息访问错误</li>
<li>性能上能否满足需求</li>
<li>是否由初始化或终止性错误</li>
</ul>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><h5 id="1-等价类划分"><a href="#1-等价类划分" class="headerlink" title="1. 等价类划分"></a>1. 等价类划分</h5><blockquote>
<p>等价类是指某个输入域的子集。</p>
<p>等价类划分是一种典型的、常用的黑盒测试方法。</p>
</blockquote>
<p>将程序的输入域划分成若干子集，每个子集中选出少数具有代表性的数据作为测试用例。</p>
<ul>
<li><p>有效等价类</p>
<blockquote>
<p>对于程序规格说明来说，由合理的、有意义的输入数据构成的集合</p>
</blockquote>
</li>
<li><p>无效等价类</p>
<blockquote>
<p>对于程序规格说明来说，由不合理的、无意义的输入数据构成的集合</p>
</blockquote>
</li>
</ul>
<p><strong>划分等价类的方法</strong>：</p>
<ul>
<li><p>按区间划分</p>
<blockquote>
<p>可能输入的数据是有一个取值范围</p>
</blockquote>
</li>
<li><p>按数值划分</p>
<blockquote>
<p>规定了输入数据的一组值</p>
</blockquote>
</li>
<li><p>按数值集合划分</p>
<blockquote>
<p>可能的输入数据属于一个值的集合(n个集合)</p>
</blockquote>
</li>
<li><p>按限制条件划分</p>
<blockquote>
<p>输入条件是个布尔值</p>
</blockquote>
</li>
<li><p>按限制规则划分</p>
<blockquote>
<p>规定了输入数据必须遵守的规则的情况下，可以建立一个有效等价类，n 个无效等价类(从不同角度违反规则)</p>
</blockquote>
</li>
<li><p>按处理方式划分</p>
<blockquote>
<p>确知已划分的等价类中各元素在程序处理中的方式不同的情况下，应再将该等价类进一步划分为更小的等价类</p>
</blockquote>
</li>
</ul>
<h5 id="2-边界值分析"><a href="#2-边界值分析" class="headerlink" title="2. 边界值分析"></a>2. 边界值分析</h5><blockquote>
<p>对输入或输出的边界值进行测试的一种黑盒测试方法。</p>
<p>通过选择等价类边界的测试用例进行测试，边界值分析方法与等价类划分方法的区别：边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件；此外，边界值分析不仅考虑输入条件边界，还要考虑输出域边界产生的测试情况。</p>
</blockquote>
<p>通常输入等价类和输出等价类的边界，就是应着重测试的边界情况。</p>
<p>应当选取正好等于，刚刚大于，刚刚小于边界的值作为测试数据。</p>
<p>典型数据：</p>
<ul>
<li>循环结构中，第 0 次，最后一次，第 1 次和倒数第 2 次是边界</li>
<li>16 位整型数据，32767 和 -32768 是边界</li>
<li>数组的第一个和最后一个下标元素是边界</li>
<li>报表的第一行和最后一行是边界</li>
</ul>
<p>通常情况下，软件测试所包含的边界检验有以下类型：数字、字符、位置、重量、速度、方位、尺寸、空间等，相应的边界值应该在：最大/最小、首位/末位、上/下、最高/最低、最快/最慢、最短/最长、空/满</p>
<p>选择测试用例的原则：</p>
<ul>
<li>如果输入条件规定了数据的范围，应该取刚达到这个范围的边界值，以及刚刚超过的边界值</li>
<li>如果规定了输入值的个数，则用最大、最小、比最大大 1、比最小小 1 个数作为测试数据</li>
<li>根据规格说明的每一个输出/输入条件，使用以上规则</li>
<li>输入域/输出域是有序集合，则选取第一个和最后一个</li>
<li>如果使用了一个内部结构，应该选择这个内部数据结构的边界值作为测试用例</li>
<li>分析规格说明，找出其他的边界条件、</li>
</ul>
<h5 id="3-错误推测法"><a href="#3-错误推测法" class="headerlink" title="3. 错误推测法"></a>3. 错误推测法</h5><blockquote>
<p>基于经验和直觉，通过观察和推测程序中的可能存在的错误，从而有针对性地设计测试用例的方法。</p>
</blockquote>
<p>基本想法：</p>
<p>列举出程序中所有可能存在的错误和容易发生错误的特殊情况，根据它们选择测试用例。</p>
<h5 id="4-因果图法"><a href="#4-因果图法" class="headerlink" title="4. 因果图法"></a>4. 因果图法</h5><blockquote>
<p>利用图解法分析输入的各种组合情况，从而设计用例的方法，适合于检查程序输入条件的各种组合情况。</p>
</blockquote>
<p>因果图：</p>
<p>4 种因果关系(原因-结果)：</p>
<p><img src="/2019/03/18/software_testing_doc/221210001415417.jpg" alt="img"></p>
<p><img src="/2019/03/18/software_testing_doc/221210556253202.jpg" alt="img"></p>
<p>5 种约束符号：</p>
<p>(原因-原因)：</p>
<p><img src="/2019/03/18/software_testing_doc/221213458284298.jpg" alt="img"></p>
<p><img src="/2019/03/18/software_testing_doc/221214109843117.jpg" alt="img"></p>
<p><img src="/2019/03/18/software_testing_doc/221214351258993.jpg" alt="img"></p>
<p><img src="/2019/03/18/software_testing_doc/221214596567753.jpg" alt="img"></p>
<p>(结果-结果)：</p>
<p><img src="/2019/03/18/software_testing_doc/221216586562242.jpg" alt="img"></p>
<p>基于因果图生成测试用例的基本步骤：</p>
<ol>
<li><p>分析软件规格说明书中，哪些是原因，哪些是结果。</p>
<blockquote>
<p>原因：输入条件/输入条件的等价类</p>
<p>结果：输出条件</p>
</blockquote>
</li>
<li><p>分析软件规格说明描述中的予以，找出原因结果之间、原因原因之间的关系，画出因果图</p>
</li>
<li><p>表明约束条件</p>
</li>
<li><p>把因果图转换成<strong>判定表</strong></p>
</li>
<li><p>为判定表中的每一例设计测试用例</p>
</li>
</ol>
<p>这里有实例：</p>
<p><a href="https://www.cnblogs.com/wanyou/p/4357231.html" target="_blank" rel="noopener">link</a></p>
<h5 id="5-场景法"><a href="#5-场景法" class="headerlink" title="5. 场景法"></a>5. 场景法</h5><blockquote>
<p>现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流，经过用例的每条路径都用基本流和备选流来表示。</p>
</blockquote>
<p>用例场景用来描述用例执行的路径，从用例开始到结束遍历这条路径上所有的基本流和备选流。</p>
<ul>
<li><p>基本流</p>
<blockquote>
<p>采用直黑线表示，经过用例最简单的路径(无任何差错，从开始执行到结束)</p>
</blockquote>
</li>
<li><p>备选流</p>
<blockquote>
<p>采用不同颜色表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流，也可以起源于另一个备选流或者终止用例，不再加入到基本流中。</p>
</blockquote>
</li>
</ul>
<p>场景法设计步骤：</p>
<ol>
<li>根据说明，描述出程序的基本流和各项备选流</li>
<li>根据基本流和备选流生成不同的场景</li>
<li>对每个场景生成相应的测试用例</li>
<li>对生成的测试用例重新复审，去掉多余的测试用例，并对确定后的每个测试用例确定测试数据值</li>
</ol>
<h5 id="6-判定表驱动"><a href="#6-判定表驱动" class="headerlink" title="6. 判定表驱动"></a>6. 判定表驱动</h5><blockquote>
<p>判定表是分析和表达多逻辑条件下执行不同操作的情况下的工具。</p>
</blockquote>
<p>判定表通常由4个部分组成：</p>
<ul>
<li><p>条件桩</p>
<blockquote>
<p>列出问题的所有条件，通常认为列出的条件次序无关紧要</p>
</blockquote>
</li>
<li><p>动作桩</p>
<blockquote>
<p>列出了问题规定可能采取的操作，这些操作的排列顺序没有约束</p>
</blockquote>
</li>
<li><p>条件项</p>
<blockquote>
<p>列出针对条件的取值和在所有可能情况下的真假值</p>
</blockquote>
</li>
<li><p>具体项</p>
<blockquote>
<p>列出在条件项的各种取值下应该采取的动作</p>
</blockquote>
</li>
</ul>
<p>生成条件表的规则：</p>
<ol>
<li>任何一个条件组合的特定取值及其要执行的相应步骤成为规则</li>
<li>把有两条或者多条具有相同的动作、且其条件项之间存在着极为相似的关系的则合并</li>
</ol>
<p>判定表建立步骤：</p>
<ol>
<li>确定规则个数</li>
<li>列出所有的条件项和动作项</li>
<li>填入条件取值</li>
<li>填入集体动作</li>
<li>简化</li>
</ol>
<p>优点：能把复杂的问题按各种情况一一列举出来，简明而易于理解，也可以避免遗漏。</p>
<p>缺点：不能表达重复执行的动作，比如循环</p>
<p>适合使用判定表设计用例的条件：</p>
<ol>
<li>规格说明以判定表形式给出或者容易建立判定表</li>
<li>条件的排列顺序不影响执行哪些操作</li>
<li>规则的排列顺序不影响执行哪些操作</li>
<li>每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则</li>
<li>如果某一规则得到满足要执行多个操作，这些操作的执行顺序无关紧要</li>
</ol>
<h5 id="7-正交试验法"><a href="#7-正交试验法" class="headerlink" title="7. 正交试验法"></a>7. 正交试验法</h5><blockquote>
<p>为了有效地，合理地减少测试的工时与费用，可以利用正交试验法。</p>
</blockquote>
<blockquote>
<p>根据近代代数中的伽罗瓦理论(Galois)，从大量的实验数据中挑选适量的有代表性的点。</p>
</blockquote>
<p>方法：聚类分析法、因子法</p>
<ul>
<li>因子：影响实验指标的条件称为因子</li>
<li>因子状态：影响实现因子的条件</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>提取功能说明，构造因子-状态列表</p>
<blockquote>
<p>根据规格说明书找出影响其功能实现的操作对象和外部因素，把它们当作因子，而把各个因子的取值当作状态。</p>
</blockquote>
</li>
<li><p>加权筛选，生成因素分析表</p>
<blockquote>
<p>对因子与状态的选择可按其重要程度分别加权</p>
</blockquote>
</li>
<li><p>利用正交表构造测试数据集</p>
</li>
</ol>
<h5 id="8-功能图法"><a href="#8-功能图法" class="headerlink" title="8. 功能图法"></a>8. 功能图法</h5><blockquote>
<p>用功能图形象地表示程序地功能说明，并机械地生成功能图的测试用例，功能图方法是一种黑盒白盒混合用例设计方法。</p>
</blockquote>
<p>程序功能说明的组成：</p>
<ul>
<li><p>动态说明</p>
<blockquote>
<p>描述输入数据的次序或转移次序</p>
</blockquote>
</li>
<li><p>静态说明</p>
<blockquote>
<p>描述输入条件和输出条件之间的对应关系</p>
</blockquote>
</li>
</ul>
<p>功能图、状态迁移图、逻辑功能模型：</p>
<ul>
<li><p>功能图</p>
<blockquote>
<p>功能图模型由状态图迁移图和逻辑功能模型构成。</p>
<p>状态迁移图用状态和迁移来表示一个状态指出数据输入的位置，一个迁移指明状态的改变，同时要依靠判定表或因果图表示的逻辑功能</p>
</blockquote>
</li>
<li><p>状态迁移图</p>
<blockquote>
<p>用于表示输入数据序列以及相应的输出数据，有输入数据和当前状态决定输出数据和后续状态</p>
</blockquote>
</li>
<li><p>逻辑功能模型</p>
<blockquote>
<p>用于表示在状态中输入条件和输出条件的对应关系，有输入数据的那个输出数据，此模型只适用于描述静态说明。</p>
</blockquote>
</li>
</ul>
<p>生成测试用例的方法：</p>
<blockquote>
<p>从状态迁移图中选取测试用例，用节点代替状态，用弧线代替迁移，状态图就可以转化成一个程序的控制流图形式。</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>生成局部测试用例</p>
<blockquote>
<p>在每个状态中，从因果图生成局部测试用例(由输入数据和对应的结果值构成)</p>
</blockquote>
</li>
<li><p>测试路径生成</p>
</li>
<li><p>测试用例合成</p>
<blockquote>
<p>将测试路径和每个状态的局部测试用例合成，结果是初始状态到最后状态的一个状态序列以及每个状态输入数据与对应输出数据的组合。</p>
</blockquote>
</li>
<li><p>采用条件构造书测试用例的合成算法</p>
</li>
</ol>
<h4 id="非功能测试"><a href="#非功能测试" class="headerlink" title="非功能测试"></a>非功能测试</h4><h5 id="1-强度测试"><a href="#1-强度测试" class="headerlink" title="1. 强度测试"></a>1. 强度测试</h5><blockquote>
<p>验证软件的性能在各种极端的周边环境和系统条件下是否能正常工作</p>
</blockquote>
<ul>
<li><p>超(满)载测试</p>
<blockquote>
<p>对软件在单位时间内所能承受的荷载的极限进行验证</p>
</blockquote>
</li>
<li><p>容量测试</p>
<blockquote>
<p>对软件系统处理大量数据的能力进行检验</p>
</blockquote>
</li>
</ul>
<h5 id="2-性能测试"><a href="#2-性能测试" class="headerlink" title="2. 性能测试"></a>2. 性能测试</h5><blockquote>
<p>验证软件的性能在正常环境和系统条件下重复使用时能否满足性能指标，性能测试是系统测试中难度较大的测试。</p>
</blockquote>
<p>软件系统性能测试包括：系统反应时间、用户反应时间、软件界面反应时间、中央处理器利用率、内存有没有泄露</p>
<h5 id="3-安全测试"><a href="#3-安全测试" class="headerlink" title="3. 安全测试"></a>3. 安全测试</h5><blockquote>
<p>检验软件数据保密性和数据完整性的测试</p>
</blockquote>
<h5 id="4-安装与卸载测试"><a href="#4-安装与卸载测试" class="headerlink" title="4. 安装与卸载测试"></a>4. 安装与卸载测试</h5><blockquote>
<p>此项测试的重要性在于安装与卸载是软件给客户的第一印象</p>
</blockquote>
<ul>
<li><p>安装</p>
<blockquote>
<p>提示是否明了、操作是否简单、安装过程是否冗长、各系统设置是否正确、安装成功后是否能正常运行、安装过程是否受其他程序影响或影响其他程序</p>
</blockquote>
</li>
<li><p>卸载</p>
<blockquote>
<p>同上，以及卸载是否干净，系统设置是否清理干净等</p>
</blockquote>
</li>
</ul>
<h5 id="5-配置测试"><a href="#5-配置测试" class="headerlink" title="5. 配置测试"></a>5. 配置测试</h5><p>三个方面：</p>
<ul>
<li>软件安装与卸载中系统配置的变化</li>
<li>软件完成安装后，人为改变配置，软件是否有相应的变化</li>
<li>硬件的不同组合是否与软件兼容</li>
</ul>
<h5 id="6-兼容性测试"><a href="#6-兼容性测试" class="headerlink" title="6. 兼容性测试"></a>6. 兼容性测试</h5><blockquote>
<p>针对测试软件与其他软件之间以及测试软件与不同硬件之间的兼容性测试</p>
<p>包括本身软件的不同版本之间</p>
</blockquote>
<ul>
<li><p>操作系统兼容</p>
</li>
<li><p>硬件兼容</p>
</li>
<li><p>软件兼容</p>
</li>
<li><p>数据库兼容</p>
</li>
<li><p>数据兼容</p>
<blockquote>
<p>不同形式的新旧数据兼容问题</p>
</blockquote>
</li>
</ul>
<h5 id="7-故障修复测试"><a href="#7-故障修复测试" class="headerlink" title="7. 故障修复测试"></a>7. 故障修复测试</h5><blockquote>
<p>为了保证软件在遇到特殊事故或者出错的情况下，一旦故障排除，即能恢复到原来的状态并正常工作</p>
</blockquote>
<h5 id="8-使用性能测试"><a href="#8-使用性能测试" class="headerlink" title="8. 使用性能测试"></a>8. 使用性能测试</h5><blockquote>
<p>从用户的角度去审视和改进软件，进而保证了软件的使用性能。</p>
</blockquote>
<p>很多时候是通过 alpha, beta 测试实现的</p>
<h5 id="9-帮助菜单和用户说明测试"><a href="#9-帮助菜单和用户说明测试" class="headerlink" title="9. 帮助菜单和用户说明测试"></a>9. 帮助菜单和用户说明测试</h5><blockquote>
<p>从用户的角度来检验使用的方便程度及其可靠性、准确性</p>
</blockquote>
<h4 id="黑盒测试策略"><a href="#黑盒测试策略" class="headerlink" title="黑盒测试策略"></a>黑盒测试策略</h4><ol>
<li>首先进行等价类划分</li>
<li>任何情况下都必须使用边界值分析法</li>
<li>利用错误推测法追加一些测试用例，这依靠测试工程师的经验和智慧</li>
<li>对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度</li>
<li>如果程序的功能说明中含有输入条件的组合情况，就可选用因果图法和判定表驱动法</li>
<li>对于参数配置类的软件，要用正交测试法选择较少的组合方式达到最佳效果</li>
<li>功能图法也是很好的测试用例设计方法</li>
<li>对于业务流清晰的系统，可以利用场景法贯穿整个测试过程</li>
</ol>
<h2 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h2><blockquote>
<p>单元测试 - 集成测试 - 系统测试 - 验收测试</p>
</blockquote>
<p><img src="/2019/03/18/software_testing_doc/772384-20171213175224488-1665785739.jpg" alt="img"></p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><blockquote>
<p>对软件设计的最小单元进行测试。</p>
<p>一般是 白盒测试</p>
</blockquote>
<h4 id="单元的选择"><a href="#单元的选择" class="headerlink" title="单元的选择"></a>单元的选择</h4><ul>
<li>单元必须是可测的</li>
<li>单元的行为或输出是可观测的</li>
<li>有明确定义的边界或接口</li>
</ul>
<p>原则：”高内聚低耦合”</p>
<h4 id="单元测试的重要性"><a href="#单元测试的重要性" class="headerlink" title="单元测试的重要性"></a>单元测试的重要性</h4><ul>
<li>节约时间，做好单元测试，在后续的集成测试等就会大大缩短时间</li>
<li>测试效果显著，单元测试做好了，后续的测试会很顺利</li>
<li>测试成本低，随着测试工作的推进，测试中发现问题带来的成本成倍数上升</li>
<li>产品质量保证</li>
</ul>
<h4 id="单元测试原则"><a href="#单元测试原则" class="headerlink" title="单元测试原则"></a>单元测试原则</h4><ol>
<li><p>越早越好</p>
<blockquote>
<p>乃至于测试驱动开发，先写测试代码，再写代码</p>
</blockquote>
</li>
<li><p>依照软件详细设计规格说明进行测试</p>
</li>
<li><p>对于修改过的代码必须重新进行单元测试，保证已经发现错误的修改没有引进新的错误</p>
</li>
<li><p>当测试用例的测试结果与设计规格说明上的预期结果不一致时，测试人员应如实记录</p>
</li>
<li><p>单元测试应注意选择好被测单元的大小</p>
</li>
<li><p>一个完整的单元测试说明包括正面测试(Positive Testing)和负面测试(Negative Testing)</p>
<blockquote>
<p>正面：测试程序应该执行的工作</p>
<p>负面：测试程序不应该执行的工作</p>
</blockquote>
</li>
<li><p>注意使用单元测试工具</p>
</li>
</ol>
<h4 id="单元测试主要任务"><a href="#单元测试主要任务" class="headerlink" title="单元测试主要任务"></a>单元测试主要任务</h4><h5 id="1-模块接口测试"><a href="#1-模块接口测试" class="headerlink" title="1. 模块接口测试"></a>1. 模块接口测试</h5><ul>
<li>模块实参和形参的类型、数量、单位等是否一致</li>
<li>调用的模块的形参和实参的类型、数量、单位是否一致</li>
<li>调用的函数参数、次序等等</li>
<li>只读型参数是否被修改</li>
<li>出现全局变量时，是不是所有的引用都有定义</li>
<li>有没有把一些约束当作参数来传递</li>
</ul>
<p>出现文件操作时：</p>
<ul>
<li>文件属性是否正确</li>
<li>文件打开格式</li>
<li>缓冲区大小</li>
<li>文件使用前是否都打开了</li>
<li>使用完毕是不是关闭了</li>
<li>文件读写结束条件是否正确</li>
</ul>
<h5 id="2-模块局部数据结构测试"><a href="#2-模块局部数据结构测试" class="headerlink" title="2. 模块局部数据结构测试"></a>2. 模块局部数据结构测试</h5><ul>
<li>不正确/不一致的类型说明</li>
<li>错误的初始化/默认值</li>
<li>错误的变量名</li>
<li>不相容的数据类型</li>
<li>下溢/上溢/地址错误</li>
</ul>
<h5 id="3-模块中所有独立执行路径请求"><a href="#3-模块中所有独立执行路径请求" class="headerlink" title="3. 模块中所有独立执行路径请求"></a>3. 模块中所有独立执行路径请求</h5><ul>
<li>误解的/不正确使用算数优先级</li>
<li>混合类型的运算</li>
<li>错误的初始化</li>
<li>算法错误</li>
<li>运算精度不够</li>
<li>表达式符号表示不正确</li>
<li>不同数据类型的比较</li>
<li>不正确的逻辑操作</li>
<li>…</li>
</ul>
<h5 id="4-各种错误处理测试"><a href="#4-各种错误处理测试" class="headerlink" title="4. 各种错误处理测试"></a>4. 各种错误处理测试</h5><p>错误：</p>
<ul>
<li>对运行发生的错误描述难以理解</li>
<li>报告的错误与实际遇到的错误不一致</li>
<li>出错后，在错误处理之前就引起了系统干预</li>
<li>例外条件的处理不正确</li>
<li>提供的错误信息不足</li>
</ul>
<h5 id="5-模块边界条件测试"><a href="#5-模块边界条件测试" class="headerlink" title="5. 模块边界条件测试"></a>5. 模块边界条件测试</h5><ul>
<li>处理 n 维数组的第 n 个元素是否出错</li>
<li>…</li>
</ul>
<h4 id="单元测试工具"><a href="#单元测试工具" class="headerlink" title="单元测试工具"></a>单元测试工具</h4><ul>
<li><p>基于 XUnit 测试框架的测试工具</p>
<blockquote>
<p>Java 中常用的 JUnit，.Net  中常用的 NUnit</p>
<p>C++ 的 CppUnit</p>
</blockquote>
</li>
<li><p>常用的C语言单元测试工具</p>
<ul>
<li><p>VcTester</p>
<blockquote>
<p>脚本化测试驱动、脚本桩、在线测试、支持持续集成测试、测试覆盖统计、测试管理、生成测试报告…</p>
</blockquote>
</li>
<li><p>C++Test</p>
<blockquote>
<p>自动化的 C/C++ 测试工具，自动测试任何 C/C++ 函数、类，自动生成测试用例、测试驱动函数，桩函数。</p>
<p>主要功能特性：</p>
<p>即时测试类、极端编程模式下的代码测试、自动建立类/函数的测试用例、自动建立类/函数的测试驱动程序或桩调用、自动回归测试、提供快速加入和执行说明和功能性测试的框架、执行部件测试(COM)</p>
</blockquote>
</li>
<li><p>Visual Unit 单元测试工具 — VU</p>
<blockquote>
<p>自动生成测试代码、快速建立了功能测试用例、高效完成了白盒覆盖、快速排错调试、生成详尽的测试报告</p>
<p>VU 具有极高的测试完整性</p>
</blockquote>
</li>
<li><p>分析覆盖率的工具</p>
<ul>
<li>LogiScope</li>
<li>TrueCoverage</li>
<li>PurecOverage</li>
</ul>
</li>
<li><p>静态分析工具</p>
<blockquote>
<p>单元测试之前，利用 pc_lint 对被测代码进行检查，排除语法错误，保证进行单元测试的代码已经具备了基本质量</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><blockquote>
<p>也叫 组合测试、联合测试</p>
<p>黑盒为主，白盒为辅</p>
</blockquote>
<h4 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h4><ul>
<li>将各模块连接检查模块调用时，数据经过接口是否丢失</li>
<li>各个子功能组合起来，检查能否达到与其要求的各项功能</li>
<li>一个模块的功能是否会对另一个模块产生不利的影响</li>
<li>全局数据结构是否有问题，会不会被异常修改</li>
<li>单个模块的误差积累起来，是否被放大，从而达到不可接受的程度</li>
</ul>
<h4 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h4><ul>
<li>所有公共接口都要测试</li>
<li>关键模块必须进行充分的测试</li>
<li>集成测试应当按一定的层次进行</li>
<li>集成测试的策略选择应该综合考虑质量、成本和进度之间的关系</li>
<li>集成测试应当尽早开始</li>
<li>在模块与接口的划分上，测试人员应当与开发人员进行充分的沟通</li>
<li>当接口发生修改时，涉及的相关接口必须进行再测试</li>
</ul>
<h4 id="集成测试方案"><a href="#集成测试方案" class="headerlink" title="集成测试方案"></a>集成测试方案</h4><h5 id="1-非增量式集成测试"><a href="#1-非增量式集成测试" class="headerlink" title="1. 非增量式集成测试"></a>1. 非增量式集成测试</h5><blockquote>
<p>一步到位</p>
<p>直接将所有模块连接，测试</p>
</blockquote>
<h5 id="2-增量式集成测试"><a href="#2-增量式集成测试" class="headerlink" title="2. 增量式集成测试"></a>2. 增量式集成测试</h5><blockquote>
<p>单元的集成是逐步实现的，集成测试也是逐步完成的</p>
</blockquote>
<ul>
<li><p>自顶向下增量式集成测试</p>
<blockquote>
<p>首先集成主控模块，然后按照软件控制层次结构向下进行集成。</p>
<p>广度优先/深度优先</p>
</blockquote>
</li>
<li><p>自底向上增量式集成测试</p>
<blockquote>
<p>从最底层的模块开始，自下而上逐步进行测试</p>
</blockquote>
</li>
</ul>
<h5 id="3-三明治集成测试"><a href="#3-三明治集成测试" class="headerlink" title="3. 三明治集成测试"></a>3. 三明治集成测试</h5><blockquote>
<p>将自顶而下和自底向上有机结合，采用并行的自顶向下和自底向上的集成方式测试。</p>
</blockquote>
<p>采取持续集成的策略，软件开发中各个模块不是同时完成，根据进度将完成的模块尽可能早地集成，有助于尽早发现缺陷，避免集成阶段大量缺陷涌现。</p>
<h5 id="4-核心系统先行集成"><a href="#4-核心系统先行集成" class="headerlink" title="4. 核心系统先行集成"></a>4. 核心系统先行集成</h5><blockquote>
<p>先对核心软件部件进行集成测试</p>
</blockquote>
<blockquote>
<p>其中也会用上增量式和非增量式集成</p>
<p>核心系统规模较小时将所有核心模块直接结成，进行测试，规模较大时可以采用增量式进行集成测试</p>
</blockquote>
<h5 id="5-高频集成测试"><a href="#5-高频集成测试" class="headerlink" title="5. 高频集成测试"></a>5. 高频集成测试</h5><blockquote>
<p>同步于软件开发，每个一段时间对开发团队的现有代码进行一次集成测试</p>
</blockquote>
<h4 id="集成测试内容"><a href="#集成测试内容" class="headerlink" title="集成测试内容"></a>集成测试内容</h4><ul>
<li>功能性测试</li>
<li>可靠性测试</li>
<li>易用性测试</li>
<li>性能测试</li>
<li>维护性测试</li>
</ul>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><blockquote>
<p>将通过集成测试的软件系统，作为计算机系统的一个重要部分，与计算机硬件、外设、某些支撑软件的系统等其他系统元素组合在一起所进行的测试，目的在于：通过与系统的需求定义作比较，发现软件与系统定义不符合或矛盾的地方。</p>
<p>完全黑盒测试</p>
<p>消耗测试资源最多的测试</p>
</blockquote>
<p>一个庞大的工程，需要预先做好准备</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>收集软件规格说明书，作为系统测试的依据</li>
<li>收集各种软件说明书，作为参考</li>
<li>仔细阅读软件测试计划书，如有独立的系统测试计划书则更好，作为系统测试的根据。</li>
</ul>
<p>找出以下内容：</p>
<ul>
<li>对系统各种功能的描述</li>
<li>系统要求的数据处理及传输速率</li>
<li>对系统性能的要求</li>
<li>对备份及修复的要求</li>
<li>对兼容性的描述</li>
<li>对配置的描述</li>
<li>对安全方面的要求</li>
<li>…</li>
</ul>
<h4 id="系统测试的主要测试技术"><a href="#系统测试的主要测试技术" class="headerlink" title="系统测试的主要测试技术"></a>系统测试的主要测试技术</h4><h5 id="1-验证测试"><a href="#1-验证测试" class="headerlink" title="1. 验证测试"></a>1. 验证测试</h5><blockquote>
<p>以前期的用户需求规格说明书的内容为依据，验证系统是否准确无误地实现了需求中的全部内容</p>
</blockquote>
<h5 id="2-功能测试"><a href="#2-功能测试" class="headerlink" title="2. 功能测试"></a>2. 功能测试</h5><blockquote>
<p>黑盒测试</p>
<p>测试输入、处理、输出等各个方面是否符合需求</p>
</blockquote>
<h5 id="3-性能测试"><a href="#3-性能测试" class="headerlink" title="3. 性能测试"></a>3. 性能测试</h5><blockquote>
<p>测试软件运行性能</p>
</blockquote>
<h5 id="4-可靠性、稳定性测试"><a href="#4-可靠性、稳定性测试" class="headerlink" title="4. 可靠性、稳定性测试"></a>4. 可靠性、稳定性测试</h5><blockquote>
<p>一定负荷的长期使用环境下，测试可靠性和稳定性</p>
</blockquote>
<h5 id="5-兼容性测试"><a href="#5-兼容性测试" class="headerlink" title="5. 兼容性测试"></a>5. 兼容性测试</h5><blockquote>
<p>测试系统中软件与各种硬件设备的兼容性、与操作系统的兼容性、与支撑软件的兼容性等</p>
</blockquote>
<h5 id="6-恢复测试"><a href="#6-恢复测试" class="headerlink" title="6. 恢复测试"></a>6. 恢复测试</h5><blockquote>
<p>采取各种方式使软件出错，测试恢复能力</p>
</blockquote>
<h5 id="7-安全测试"><a href="#7-安全测试" class="headerlink" title="7. 安全测试"></a>7. 安全测试</h5><blockquote>
<p>检测软件对非法侵入行文的防范能力，就是设置一些企图突破安全保密措施的用例，检查是否有漏洞</p>
</blockquote>
<h5 id="8-强度测试"><a href="#8-强度测试" class="headerlink" title="8. 强度测试"></a>8. 强度测试</h5><h5 id="9-用户支持测试"><a href="#9-用户支持测试" class="headerlink" title="9. 用户支持测试"></a>9. 用户支持测试</h5><h5 id="10-用户界面测试"><a href="#10-用户界面测试" class="headerlink" title="10. 用户界面测试"></a>10. 用户界面测试</h5><h5 id="11-其他"><a href="#11-其他" class="headerlink" title="11. 其他"></a>11. 其他</h5><ul>
<li>可使用性</li>
<li>可维护性</li>
<li>可移植性</li>
</ul>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><blockquote>
<p>验证软件功能的正确性和需求的符合性。</p>
</blockquote>
<blockquote>
<p>确保软件准备就绪，应该着重考虑软件是否满足合同规定的所有功能和性能，文档资料是否完整，人机界面和其他方面是否令用户满意等</p>
</blockquote>
<h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><h5 id="1-配置复审"><a href="#1-配置复审" class="headerlink" title="1. 配置复审"></a>1. 配置复审</h5><blockquote>
<p>保证配置齐全，分类有序，包括软件维护所必须的细节</p>
</blockquote>
<h5 id="2-合法性检查"><a href="#2-合法性检查" class="headerlink" title="2. 合法性检查"></a>2. 合法性检查</h5><blockquote>
<p>使用开发者在开发软件时，使用的开发工具是否合法</p>
</blockquote>
<h5 id="3-软件文档检查"><a href="#3-软件文档检查" class="headerlink" title="3. 软件文档检查"></a>3. 软件文档检查</h5><p>需要检查的文档：</p>
<ul>
<li>项目实施计划</li>
<li>详细技术方案</li>
<li>软件需求规格说明书</li>
<li>概要设计说明书</li>
<li>详细设计说明书</li>
<li>软件测试计划</li>
<li>软件测试报告</li>
<li>用户手册</li>
<li>源程序</li>
<li>项目实施计划</li>
<li>项目开发总结</li>
<li>软件质量保证计划</li>
<li>软件配置计划</li>
<li>项目进展报表</li>
<li>阶段评审报表</li>
</ul>
<p>文档的质量准则：</p>
<ul>
<li>完备性</li>
<li>正确性</li>
<li>简明性</li>
<li>可追踪性</li>
<li>自说明性</li>
<li>规范性</li>
</ul>
<h5 id="4-软件代码测试"><a href="#4-软件代码测试" class="headerlink" title="4. 软件代码测试"></a>4. 软件代码测试</h5><ul>
<li><p>源代码一般性检查</p>
<blockquote>
<p>仅对系统关键模块的源代码进行抽查，检 查模块代码编写的规范性、批注的准确性、是否存在潜在性错误以及代码的可维护性等</p>
</blockquote>
<ul>
<li>命名规范</li>
<li>接口</li>
<li>注释</li>
<li>数据类型</li>
<li>限制性检查</li>
</ul>
</li>
<li><p>软件一致性检查</p>
<ul>
<li>编译检查</li>
<li>装/卸载检查</li>
<li>运行模块检查</li>
</ul>
</li>
</ul>
<h5 id="5-软件功能测试和性能测试"><a href="#5-软件功能测试和性能测试" class="headerlink" title="5. 软件功能测试和性能测试"></a>5. 软件功能测试和性能测试</h5><blockquote>
<p>检测软件的整体行为表现，对软件开发设计的再确认。</p>
</blockquote>
<ul>
<li>界面测试</li>
<li>可用性测试</li>
<li>功能测试</li>
<li>稳定性测试</li>
<li>性能测试</li>
<li>强壮性测试</li>
<li>逻辑性测试</li>
<li>破坏性测试</li>
<li>安全性测试</li>
</ul>
<h5 id="6-测试结果交付内容"><a href="#6-测试结果交付内容" class="headerlink" title="6. 测试结果交付内容"></a>6. 测试结果交付内容</h5><ul>
<li>软件测试计划</li>
<li>软件测试日志</li>
<li>软件文档检查报告</li>
<li>软件代码测试报告</li>
<li>软件系统测试报告</li>
<li>测试总结报告</li>
<li>测试人员签字登记表</li>
</ul>
<h4 id="alpha-amp-beta-测试"><a href="#alpha-amp-beta-测试" class="headerlink" title="$\alpha\  \&amp;\ \beta$ 测试"></a>$\alpha\  \&amp;\ \beta$ 测试</h4><h5 id="alpha-测试"><a href="#alpha-测试" class="headerlink" title="$\alpha$ 测试"></a>$\alpha$ 测试</h5><blockquote>
<p>在软件开发公司内模拟软件系统的运行环境下的一种验收测试</p>
</blockquote>
<h5 id="beta-测试"><a href="#beta-测试" class="headerlink" title="$\beta$ 测试"></a>$\beta$ 测试</h5><p>经过 $\alpha$ 测试的软件产品称为 $\beta$ 版本，随即执行的 $\beta$ 测试</p>
<blockquote>
<p>组织各方面的典型用户在日常工作中实际使用 $\beta$ 版本，并要求用户报告异常情况，提出批评意见，然后开发公司再对 $\beta$ 版本进行改进和完善</p>
</blockquote>
<h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><blockquote>
<p>软件系统被修改/扩充之后重新进行的测试</p>
</blockquote>
<blockquote>
<p>严格意义上不算是一个测试阶段，而是一个测试技术，应用于整个测试过程乃至每个测试阶段</p>
</blockquote>
<p>错误猜测在回归测试中很重要。</p>
<h4 id="回归测试的范围"><a href="#回归测试的范围" class="headerlink" title="回归测试的范围"></a>回归测试的范围</h4><ul>
<li>局限在修改范围内的测试</li>
<li>在受影响功能范围内回归</li>
<li>根据一定的覆盖率指标选择回归测试</li>
</ul>
<h2 id="系统排错"><a href="#系统排错" class="headerlink" title="系统排错"></a>系统排错</h2><blockquote>
<p>根据测试时发现的错误，找出原因和具体的位置，并进行改正</p>
</blockquote>
<h3 id="排错方法"><a href="#排错方法" class="headerlink" title="排错方法"></a>排错方法</h3><ul>
<li><p>原始类排错法</p>
<blockquote>
<p>最常用也最低效</p>
</blockquote>
<blockquote>
<p>主要思想：”通过计算机找错”</p>
<p>凭借大量的现场信息，从中找到出错的线索，虽然最终也能成功，但会耗费大量时间和精力</p>
</blockquote>
</li>
<li><p>回溯法</p>
<blockquote>
<p>从错误的征兆开始，人工地沿控制流程往回追踪，直至发现出错的根源</p>
</blockquote>
</li>
<li><p>归纳和演绎法</p>
<blockquote>
<p>“分治”</p>
<p>基于与错误出现有关的所有数据，假想一个错误原因，用这些数据反驳/证明它，或者一次列出所有可能的原因，通过测试一一排除，逐步精化数据，逐步进行深入地测试。</p>
</blockquote>
</li>
</ul>
<p>几个排错时常用的技术</p>
<ul>
<li>断点设置</li>
<li>可疑变量查看</li>
<li>SQL 语句执行检查</li>
<li>注意群集现象</li>
</ul>
<p>以上方法均可辅以排错工具：</p>
<p>调试编译器、动态调试器、测试用例自动生成器、存储器映像、交叉访问视图等</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/17/Linux 学习之路/" rel="next" title="Linux 基础">
                <i class="fa fa-chevron-left"></i> Linux 基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/27/ubuntu_install_phantomjs/" rel="prev" title="install phantomjs on ubuntu 16.04">
                install phantomjs on ubuntu 16.04 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Runqian Chen</p>
              <p class="site-description motion-element" itemprop="description">Personnal blogger</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件质量"><span class="nav-text">软件质量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件质量因素"><span class="nav-text">软件质量因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件质量模型"><span class="nav-text">软件质量模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件缺陷"><span class="nav-text">软件缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缺陷产生原因"><span class="nav-text">缺陷产生原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开发阶段"><span class="nav-text">开发阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#项目管理"><span class="nav-text">项目管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#团队工作"><span class="nav-text">团队工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复审"><span class="nav-text">复审</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺陷内容"><span class="nav-text">缺陷内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件测试"><span class="nav-text">软件测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本原则"><span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件测试过程模型"><span class="nav-text">软件测试过程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-V-模型"><span class="nav-text">1. V 模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-W-model"><span class="nav-text">2. W model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-X-model"><span class="nav-text">3.  X model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-H-Model"><span class="nav-text">4. H Model</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件测试分类"><span class="nav-text">软件测试分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-按测试方式分类"><span class="nav-text">1. 按测试方式分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-按测试方法分类"><span class="nav-text">2. 按测试方法分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-按测试过程分类"><span class="nav-text">3. 按测试过程分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-按测试目的分类"><span class="nav-text">4. 按测试目的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件测试流程"><span class="nav-text">软件测试流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-制定测试计划"><span class="nav-text">1. 制定测试计划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-设计测试方案"><span class="nav-text">2. 设计测试方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-测试准备和测试环境的建立"><span class="nav-text">3. 测试准备和测试环境的建立</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-执行测试"><span class="nav-text">4. 执行测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-测试评估"><span class="nav-text">5. 测试评估</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-测试总结"><span class="nav-text">6. 测试总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件测试计划制定"><span class="nav-text">软件测试计划制定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原则"><span class="nav-text">原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何制定测试计划"><span class="nav-text">如何制定测试计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#衡量测试计划的标准"><span class="nav-text">衡量测试计划的标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#制定测试计划"><span class="nav-text">制定测试计划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件测试基本技术"><span class="nav-text">软件测试基本技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#白盒测试"><span class="nav-text">白盒测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态测试"><span class="nav-text">静态测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-代码检查法"><span class="nav-text">1. 代码检查法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-静态结构分析法"><span class="nav-text">2. 静态结构分析法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态测试"><span class="nav-text">动态测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-程序插桩"><span class="nav-text">1. 程序插桩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-逻辑覆盖"><span class="nav-text">2. 逻辑覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-基本路径测试"><span class="nav-text">3. 基本路径测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他白盒测试方法"><span class="nav-text">其他白盒测试方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-域测试"><span class="nav-text">1. 域测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-符号测试"><span class="nav-text">2. 符号测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Z-路径覆盖"><span class="nav-text">3. Z 路径覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-程序变异"><span class="nav-text">4. 程序变异</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#白盒测试应用策略"><span class="nav-text">白盒测试应用策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#黑盒测试"><span class="nav-text">黑盒测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#功能测试"><span class="nav-text">功能测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-等价类划分"><span class="nav-text">1. 等价类划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-边界值分析"><span class="nav-text">2. 边界值分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-错误推测法"><span class="nav-text">3. 错误推测法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-因果图法"><span class="nav-text">4. 因果图法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-场景法"><span class="nav-text">5. 场景法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-判定表驱动"><span class="nav-text">6. 判定表驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-正交试验法"><span class="nav-text">7. 正交试验法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-功能图法"><span class="nav-text">8. 功能图法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非功能测试"><span class="nav-text">非功能测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-强度测试"><span class="nav-text">1. 强度测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-性能测试"><span class="nav-text">2. 性能测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-安全测试"><span class="nav-text">3. 安全测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-安装与卸载测试"><span class="nav-text">4. 安装与卸载测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-配置测试"><span class="nav-text">5. 配置测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-兼容性测试"><span class="nav-text">6. 兼容性测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-故障修复测试"><span class="nav-text">7. 故障修复测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-使用性能测试"><span class="nav-text">8. 使用性能测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-帮助菜单和用户说明测试"><span class="nav-text">9. 帮助菜单和用户说明测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#黑盒测试策略"><span class="nav-text">黑盒测试策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件测试过程"><span class="nav-text">软件测试过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单元测试"><span class="nav-text">单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单元的选择"><span class="nav-text">单元的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单元测试的重要性"><span class="nav-text">单元测试的重要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单元测试原则"><span class="nav-text">单元测试原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单元测试主要任务"><span class="nav-text">单元测试主要任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-模块接口测试"><span class="nav-text">1. 模块接口测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-模块局部数据结构测试"><span class="nav-text">2. 模块局部数据结构测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-模块中所有独立执行路径请求"><span class="nav-text">3. 模块中所有独立执行路径请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-各种错误处理测试"><span class="nav-text">4. 各种错误处理测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-模块边界条件测试"><span class="nav-text">5. 模块边界条件测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单元测试工具"><span class="nav-text">单元测试工具</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集成测试"><span class="nav-text">集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要任务"><span class="nav-text">主要任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原则-1"><span class="nav-text">原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集成测试方案"><span class="nav-text">集成测试方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-非增量式集成测试"><span class="nav-text">1. 非增量式集成测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-增量式集成测试"><span class="nav-text">2. 增量式集成测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-三明治集成测试"><span class="nav-text">3. 三明治集成测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-核心系统先行集成"><span class="nav-text">4. 核心系统先行集成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-高频集成测试"><span class="nav-text">5. 高频集成测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集成测试内容"><span class="nav-text">集成测试内容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统测试"><span class="nav-text">系统测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#准备工作"><span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统测试的主要测试技术"><span class="nav-text">系统测试的主要测试技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-验证测试"><span class="nav-text">1. 验证测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-功能测试"><span class="nav-text">2. 功能测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-性能测试"><span class="nav-text">3. 性能测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-可靠性、稳定性测试"><span class="nav-text">4. 可靠性、稳定性测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-兼容性测试"><span class="nav-text">5. 兼容性测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-恢复测试"><span class="nav-text">6. 恢复测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-安全测试"><span class="nav-text">7. 安全测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-强度测试"><span class="nav-text">8. 强度测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-用户支持测试"><span class="nav-text">9. 用户支持测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-用户界面测试"><span class="nav-text">10. 用户界面测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-其他"><span class="nav-text">11. 其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验收测试"><span class="nav-text">验收测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要内容"><span class="nav-text">主要内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-配置复审"><span class="nav-text">1. 配置复审</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-合法性检查"><span class="nav-text">2. 合法性检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-软件文档检查"><span class="nav-text">3. 软件文档检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-软件代码测试"><span class="nav-text">4. 软件代码测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-软件功能测试和性能测试"><span class="nav-text">5. 软件功能测试和性能测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-测试结果交付内容"><span class="nav-text">6. 测试结果交付内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alpha-amp-beta-测试"><span class="nav-text">$\alpha\  \&amp;\ \beta$ 测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#alpha-测试"><span class="nav-text">$\alpha$ 测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#beta-测试"><span class="nav-text">$\beta$ 测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回归测试"><span class="nav-text">回归测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回归测试的范围"><span class="nav-text">回归测试的范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统排错"><span class="nav-text">系统排错</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排错方法"><span class="nav-text">排错方法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Runqian Chen</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
